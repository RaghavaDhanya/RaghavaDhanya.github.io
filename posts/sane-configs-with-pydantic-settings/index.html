<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Keeping Configurations Sane with Pydantic Settings | AI Logs</title>
<meta name=keywords content="yaml,configurations,python,pydantic"><meta name=description content="Configurations are a crucial aspect of any software project. There are many sources of configurations, such as environment variables, configuration files, and command-line arguments. For file-based configurations in python, YAML and TOML (or INI) are popular choices. I prefer YAML, though it is not without flaws, some of which can be addressed by Pydantic anyway like type safety etc.
Pydantic is a data validation library for Python. It is built on top of Python type hints and provides runtime validation of data. Pydantic is widely used for data validation for APIs, but it can also be used for configuration management. Pydantic has a settings management library called pydantic-settings that makes it easy to load configurations from multiple sources."><meta name=author content="Raghava Dhanya"><link rel=canonical href=https://ai.ragv.in/posts/sane-configs-with-pydantic-settings/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://ai.ragv.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ai.ragv.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ai.ragv.in/favicon-32x32.png><link rel=apple-touch-icon href=https://ai.ragv.in/apple-touch-icon.png><link rel=mask-icon href=https://ai.ragv.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ai.ragv.in/posts/sane-configs-with-pydantic-settings/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-RGHWYFE1WN"></script><script>var dnt,doNotTrack=!1;if(!0&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RGHWYFE1WN")}</script><meta property="og:url" content="https://ai.ragv.in/posts/sane-configs-with-pydantic-settings/"><meta property="og:site_name" content="AI Logs"><meta property="og:title" content="Keeping Configurations Sane with Pydantic Settings"><meta property="og:description" content="Configurations are a crucial aspect of any software project. There are many sources of configurations, such as environment variables, configuration files, and command-line arguments. For file-based configurations in python, YAML and TOML (or INI) are popular choices. I prefer YAML, though it is not without flaws, some of which can be addressed by Pydantic anyway like type safety etc.
Pydantic is a data validation library for Python. It is built on top of Python type hints and provides runtime validation of data. Pydantic is widely used for data validation for APIs, but it can also be used for configuration management. Pydantic has a settings management library called pydantic-settings that makes it easy to load configurations from multiple sources."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-14T11:54:11+05:30"><meta property="article:modified_time" content="2023-11-14T11:54:11+05:30"><meta property="article:tag" content="Yaml"><meta property="article:tag" content="Configurations"><meta property="article:tag" content="Python"><meta property="article:tag" content="Pydantic"><meta property="og:image" content="https://ai.ragv.in/images/sane-configs-with-pydantic-settings/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ai.ragv.in/images/sane-configs-with-pydantic-settings/cover.jpg"><meta name=twitter:title content="Keeping Configurations Sane with Pydantic Settings"><meta name=twitter:description content="Configurations are a crucial aspect of any software project. There are many sources of configurations, such as environment variables, configuration files, and command-line arguments. For file-based configurations in python, YAML and TOML (or INI) are popular choices. I prefer YAML, though it is not without flaws, some of which can be addressed by Pydantic anyway like type safety etc.
Pydantic is a data validation library for Python. It is built on top of Python type hints and provides runtime validation of data. Pydantic is widely used for data validation for APIs, but it can also be used for configuration management. Pydantic has a settings management library called pydantic-settings that makes it easy to load configurations from multiple sources."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ai.ragv.in/posts/"},{"@type":"ListItem","position":2,"name":"Keeping Configurations Sane with Pydantic Settings","item":"https://ai.ragv.in/posts/sane-configs-with-pydantic-settings/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Keeping Configurations Sane with Pydantic Settings","name":"Keeping Configurations Sane with Pydantic Settings","description":"Configurations are a crucial aspect of any software project. There are many sources of configurations, such as environment variables, configuration files, and command-line arguments. For file-based configurations in python, YAML and TOML (or INI) are popular choices. I prefer YAML, though it is not without flaws, some of which can be addressed by Pydantic anyway like type safety etc.\nPydantic is a data validation library for Python. It is built on top of Python type hints and provides runtime validation of data. Pydantic is widely used for data validation for APIs, but it can also be used for configuration management. Pydantic has a settings management library called pydantic-settings that makes it easy to load configurations from multiple sources.\n","keywords":["yaml","configurations","python","pydantic"],"articleBody":"Configurations are a crucial aspect of any software project. There are many sources of configurations, such as environment variables, configuration files, and command-line arguments. For file-based configurations in python, YAML and TOML (or INI) are popular choices. I prefer YAML, though it is not without flaws, some of which can be addressed by Pydantic anyway like type safety etc.\nPydantic is a data validation library for Python. It is built on top of Python type hints and provides runtime validation of data. Pydantic is widely used for data validation for APIs, but it can also be used for configuration management. Pydantic has a settings management library called pydantic-settings that makes it easy to load configurations from multiple sources.\nIn this post, we’ll go through some of my favorite ways to manage configurations using Pydantic and pydantic-settings. We’ll start with a simple example of loading configurations from a YAML file and then move on to loading configurations from multiple sources.\npip install pydantic\u003e=2 pydantic-settings pyyaml I’m using pydantic-settings 2.1.0 and pydantic 2.3.0 in the rest of the post.\nLet’s start with a simple YAML configuration file.\n# config.yaml host: localhost port: 5432 username: user password: password We can define a Pydantic model to represent this configuration. We are just using pydantic, we’ll use pydantic-settings in more complex examples.\nfrom pydantic import BaseModel class DatabaseConfig(BaseModel): host: str port: int username: str password: str We can then use the pydantic module to parse the YAML configuration file.\nimport yaml from pydantic import ValidationError with open(\"config.yaml\", \"r\") as file: try: config = DatabaseConfig(**yaml.safe_load(file)) except ValidationError as e: print(\"Invalid configuration file\", e.json()) We can now access the configuration values using the model attributes.\nprint(config.host) print(config.port) print(config.username) print(config.password) The types have been validated. You can define default values, constraints, and more using Pydantic. You can refer to the Pydantic documentation for more information.\nNow let’s see how we can use pydantic-settings to load configurations from multiple sources.\nEnvironment Variables Source from pydantic_settings import BaseSettings, SettingsConfigDict class Settings(BaseSettings): host: str = \"localhost\" port: int = 5432 username: str = \"user\" password: str = \"password\" model_config = SettingsConfigDict(env_prefix=\"APP_\") settings = Settings() Now, the configurations can be loaded from environment variables with the APP_ prefix. For example, APP_HOST, APP_PORT, APP_USERNAME, and APP_PASSWORD.\nexport APP_HOST=example.com export APP_PORT=8080 export APP_USERNAME=admin export APP_PASSWORD=secret But the configurations can no longer be loaded from the YAML file. To load from yaml we need to add another source.\nYAML File Source from abc import abstractmethod from typing import Any, Dict, Tuple, Type from pydantic.fields import FieldInfo from pydantic_settings import BaseSettings from pydantic_settings import PydanticBaseSettingsSource import yaml class BaseFileConfigSettingsSource(PydanticBaseSettingsSource): def __init__(self, settings_cls: Type[BaseSettings], path: str): super().__init__(settings_cls) self._data = self.load_file(path) @abstractmethod def load_file(self, path: str) -\u003e Dict[str, Any]: pass def get_field_value( self, field: FieldInfo, field_name: str ) -\u003e Tuple[Any, str, bool]: if field_name in self._data: return self._data[field_name], field_name, True else: return field.default, field_name, False def __call__(self) -\u003e Dict[str, Any]: settings = {} for field_name, field in self.settings_cls.model_fields.items(): value, _, _ = self.get_field_value(field, field_name) settings[field_name] = value return settings class YamlConfigSettingsSource(BaseFileConfigSettingsSource): def load_file(self, path: str) -\u003e Dict[str, Any]: with open(path, \"r\") as f: return yaml.safe_load(f) class Settings(BaseSettings): ... @classmethod def settings_customise_sources( cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource, ) -\u003e Tuple[PydanticBaseSettingsSource, ...]: return ( env_settings, YamlConfigSettingsSource(settings_cls, \"config.yaml\"), init_settings, ) Now the configurations can be loaded from both environment variables and the YAML file. The environment variables take precedence over the YAML file. This is generally what I use in my projects. You can override the config file’s values with environment variables. This can be easily extended to TOML or other file formats as long as you can parse them into a dictionary.\nCommand-line Arguments Source Another source of configurations can be command-line arguments. I achieved this by just extending the EnvSettingsSource class.\nimport sys from typing import Type from pydantic_settings import BaseSettings from pydantic_settings.sources import EnvSettingsSource class CliArgsSource(EnvSettingsSource): def __init__(self, settings_cls: Type[BaseSettings], prefix: str = \"config_\"): super().__init__(settings_cls, env_prefix=prefix) self._prefix = prefix self.env_vars = self._load_args() def _load_args(self): args = sys.argv[1:] env_vars = {} for i in range(len(args)): if args[i].startswith(f\"--{self._prefix}\"): if \"=\" in args[i]: key, value = args[i].split(\"=\") key = key[2:].strip() env_vars[key] = value.strip() elif i + 1 \u003c len(args) and not args[i + 1].startswith(\"--\"): key = args[i][2:].strip() env_vars[key] = args[i + 1].strip() return env_vars class Settings(BaseSettings): ... @classmethod def settings_customise_sources( cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource, ) -\u003e Tuple[PydanticBaseSettingsSource, ...]: return ( env_settings, YamlConfigSettingsSource(settings_cls, \"config.yaml\"), CliArgsSource(settings_cls, \"app_\"), init_settings, ) Now you can pass command-line arguments like --app_host=example.com to override the configurations from the YAML file and environment variables. This way, you can have a single source of truth for all your configurations.\nNested Configurations Pydantic also supports nested models, which can be useful for complex configurations. Let’s say you have a nested configuration like this:\n# config.yaml database: host: localhost port: 5432 username: user password: password app: name: myapp version: 1.0 You can define nested models like this:\nfrom pydantic import BaseModel from pydantic_settings import BaseSettings, SettingsConfigDict class DatabaseConfig(BaseModel): host: str port: int username: str password: str class AppConfig(BaseModel): name: str version: str class Settings(BaseSettings): database: DatabaseConfig app: AppConfig model_config = SettingsConfigDict(env_prefix=\"APP_\", env_nested_delimiter=\"__\") @classmethod def settings_customise_sources( cls, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource, ) -\u003e Tuple[PydanticBaseSettingsSource, ...]: return ( env_settings, CliArgsSource(settings_cls, \"app_\"), YamlConfigSettingsSource(settings_cls, \"config.yaml\"), init_settings, ) You can pass the nested configurations as environment variables with the separator __.\nFor example,\nexport APP_DATABASE__HOST=example.com export APP_DATABASE__PORT=8080 export APP_DATABASE__USERNAME=admin export APP_DATABASE__PASSWORD=secret export APP_APP__NAME=myapp export APP_APP__VERSION=1.0 And since we are using EnvSettingsSource as base class for CliArgsSource, you can pass nested configurations as command-line arguments like\npython app.py --app_database__host=example.com --app_database__port=8080 --app_database__username=admin --app_database__password=secret --app_app__name=myapp --app_app__version=1.0 Conclusion Pydantic and pydantic-settings provide a powerful way to manage configurations in Python. You can load configurations from multiple sources like environment variables, YAML files, and command-line arguments. You can also define nested configurations and customize the sources to suit your needs. This makes it easy to manage configurations in a consistent and type-safe way. I hope this post helps you keep your configurations sane in your Python projects.\n","wordCount":"1004","inLanguage":"en","image":"https://ai.ragv.in/images/sane-configs-with-pydantic-settings/cover.jpg","datePublished":"2023-11-14T11:54:11+05:30","dateModified":"2023-11-14T11:54:11+05:30","author":{"@type":"Person","name":"[Raghava Dhanya](https://ragv.in)"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ai.ragv.in/posts/sane-configs-with-pydantic-settings/"},"publisher":{"@type":"Person","name":"AI Logs","logo":{"@type":"ImageObject","url":"https://ai.ragv.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ai.ragv.in/ accesskey=h title="AI Logs (Alt + H)"><img src=https://ai.ragv.in/Logo_2_0.svg alt aria-label=logo height=30>AI Logs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ai.ragv.in/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://ai.ragv.in/categories/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://ai.ragv.in/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ragv.in title=ragv.in><span>ragv.in</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://ai.ragv.in/archives title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ai.ragv.in/>Home</a>&nbsp;»&nbsp;<a href=https://ai.ragv.in/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Keeping Configurations Sane with Pydantic Settings</h1><div class=post-meta><span title='2023-11-14 11:54:11 +0530 +0530'>November 14, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;<a href=https://ragv.in>Raghava Dhanya</a></div></header><figure class=entry-cover><img loading=eager src=https://ai.ragv.in/images/sane-configs-with-pydantic-settings/cover.jpg alt=Configurations><p>Configurations</p></figure><div class=post-content><p>Configurations are a crucial aspect of any software project. There are many sources of configurations, such as environment variables, configuration files, and command-line arguments. For file-based configurations in python, YAML and TOML (or INI) are popular choices. I prefer YAML, though it is not without flaws, some of which can be addressed by Pydantic anyway like type safety etc.</p><p>Pydantic is a data validation library for Python. It is built on top of Python type hints and provides runtime validation of data. Pydantic is widely used for data validation for APIs, but it can also be used for configuration management. Pydantic has a settings management library called <code>pydantic-settings</code> that makes it easy to load configurations from multiple sources.</p><p>In this post, we&rsquo;ll go through some of my favorite ways to manage configurations using Pydantic and <code>pydantic-settings</code>. We&rsquo;ll start with a simple example of loading configurations from a YAML file and then move on to loading configurations from multiple sources.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install pydantic&gt;<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> pydantic-settings pyyaml
</span></span></code></pre></div><p>I&rsquo;m using pydantic-settings 2.1.0 and pydantic 2.3.0 in the rest of the post.</p><p>Let&rsquo;s start with a simple YAML configuration file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># config.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>host</span>: <span style=color:#ae81ff>localhost</span>
</span></span><span style=display:flex><span><span style=color:#f92672>port</span>: <span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span><span style=color:#f92672>username</span>: <span style=color:#ae81ff>user</span>
</span></span><span style=display:flex><span><span style=color:#f92672>password</span>: <span style=color:#ae81ff>password</span>
</span></span></code></pre></div><p>We can define a Pydantic model to represent this configuration. We are just using pydantic, we&rsquo;ll use pydantic-settings in more complex examples.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pydantic <span style=color:#f92672>import</span> BaseModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseConfig</span>(BaseModel):
</span></span><span style=display:flex><span>    host: str
</span></span><span style=display:flex><span>    port: int
</span></span><span style=display:flex><span>    username: str
</span></span><span style=display:flex><span>    password: str
</span></span></code></pre></div><p>We can then use the <code>pydantic</code> module to parse the YAML configuration file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> yaml
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic <span style=color:#f92672>import</span> ValidationError
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;config.yaml&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        config <span style=color:#f92672>=</span> DatabaseConfig(<span style=color:#f92672>**</span>yaml<span style=color:#f92672>.</span>safe_load(file))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> ValidationError <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Invalid configuration file&#34;</span>, e<span style=color:#f92672>.</span>json())
</span></span></code></pre></div><p>We can now access the configuration values using the model attributes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(config<span style=color:#f92672>.</span>host)
</span></span><span style=display:flex><span>print(config<span style=color:#f92672>.</span>port)
</span></span><span style=display:flex><span>print(config<span style=color:#f92672>.</span>username)
</span></span><span style=display:flex><span>print(config<span style=color:#f92672>.</span>password)
</span></span></code></pre></div><p>The types have been validated. You can define default values, constraints, and more using Pydantic. You can refer to the <a href=https://docs.pydantic.dev/latest/>Pydantic documentation</a> for more information.</p><p>Now let&rsquo;s see how we can use <code>pydantic-settings</code> to load configurations from multiple sources.</p><h3 id=environment-variables-source>Environment Variables Source<a hidden class=anchor aria-hidden=true href=#environment-variables-source>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pydantic_settings <span style=color:#f92672>import</span> BaseSettings, SettingsConfigDict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Settings</span>(BaseSettings):
</span></span><span style=display:flex><span>    host: str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;localhost&#34;</span>
</span></span><span style=display:flex><span>    port: int <span style=color:#f92672>=</span> <span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span>    username: str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;user&#34;</span>
</span></span><span style=display:flex><span>    password: str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;password&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    model_config <span style=color:#f92672>=</span> SettingsConfigDict(env_prefix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;APP_&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>settings <span style=color:#f92672>=</span> Settings()
</span></span></code></pre></div><p>Now, the configurations can be loaded from environment variables with the <code>APP_</code> prefix. For example, <code>APP_HOST</code>, <code>APP_PORT</code>, <code>APP_USERNAME</code>, and <code>APP_PASSWORD</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export APP_HOST<span style=color:#f92672>=</span>example.com
</span></span><span style=display:flex><span>export APP_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>export APP_USERNAME<span style=color:#f92672>=</span>admin
</span></span><span style=display:flex><span>export APP_PASSWORD<span style=color:#f92672>=</span>secret
</span></span></code></pre></div><p>But the configurations can no longer be loaded from the YAML file. To load from yaml we need to add another source.</p><h3 id=yaml-file-source>YAML File Source<a hidden class=anchor aria-hidden=true href=#yaml-file-source>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> abc <span style=color:#f92672>import</span> abstractmethod
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Any, Dict, Tuple, Type
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic.fields <span style=color:#f92672>import</span> FieldInfo
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic_settings <span style=color:#f92672>import</span> BaseSettings
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic_settings <span style=color:#f92672>import</span> PydanticBaseSettingsSource
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseFileConfigSettingsSource</span>(PydanticBaseSettingsSource):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, settings_cls: Type[BaseSettings], path: str):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(settings_cls)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_data <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>load_file(path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_file</span>(self, path: str) <span style=color:#f92672>-&gt;</span> Dict[str, Any]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_field_value</span>(
</span></span><span style=display:flex><span>        self, field: FieldInfo, field_name: str
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> Tuple[Any, str, bool]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> field_name <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>_data:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_data[field_name], field_name, <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> field<span style=color:#f92672>.</span>default, field_name, <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __call__(self) <span style=color:#f92672>-&gt;</span> Dict[str, Any]:
</span></span><span style=display:flex><span>        settings <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> field_name, field <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>settings_cls<span style=color:#f92672>.</span>model_fields<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            value, _, _ <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_field_value(field, field_name)
</span></span><span style=display:flex><span>            settings[field_name] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> settings
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>YamlConfigSettingsSource</span>(BaseFileConfigSettingsSource):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_file</span>(self, path: str) <span style=color:#f92672>-&gt;</span> Dict[str, Any]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> open(path, <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> yaml<span style=color:#f92672>.</span>safe_load(f)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Settings</span>(BaseSettings):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>settings_customise_sources</span>(
</span></span><span style=display:flex><span>        cls,
</span></span><span style=display:flex><span>        settings_cls: Type[BaseSettings],
</span></span><span style=display:flex><span>        init_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        env_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        dotenv_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        file_secret_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> Tuple[PydanticBaseSettingsSource, <span style=color:#f92672>...</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            env_settings,
</span></span><span style=display:flex><span>            YamlConfigSettingsSource(settings_cls, <span style=color:#e6db74>&#34;config.yaml&#34;</span>),
</span></span><span style=display:flex><span>            init_settings,
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>Now the configurations can be loaded from both environment variables and the YAML file. The environment variables take precedence over the YAML file. This is generally what I use in my projects. You can override the config file&rsquo;s values with environment variables. This can be easily extended to TOML or other file formats as long as you can parse them into a dictionary.</p><h3 id=command-line-arguments-source>Command-line Arguments Source<a hidden class=anchor aria-hidden=true href=#command-line-arguments-source>#</a></h3><p>Another source of configurations can be command-line arguments. I achieved this by just extending the EnvSettingsSource class.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Type
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic_settings <span style=color:#f92672>import</span> BaseSettings
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic_settings.sources <span style=color:#f92672>import</span> EnvSettingsSource
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CliArgsSource</span>(EnvSettingsSource):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, settings_cls: Type[BaseSettings], prefix: str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;config_&#34;</span>):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(settings_cls, env_prefix<span style=color:#f92672>=</span>prefix)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_prefix <span style=color:#f92672>=</span> prefix
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>env_vars <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_load_args()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_load_args</span>(self):
</span></span><span style=display:flex><span>        args <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>        env_vars <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(args)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> args[i]<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;--</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>_prefix<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>in</span> args[i]:
</span></span><span style=display:flex><span>                    key, value <span style=color:#f92672>=</span> args[i]<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;=&#34;</span>)
</span></span><span style=display:flex><span>                    key <span style=color:#f92672>=</span> key[<span style=color:#ae81ff>2</span>:]<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                    env_vars[key] <span style=color:#f92672>=</span> value<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>elif</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> len(args) <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> args[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#34;--&#34;</span>):
</span></span><span style=display:flex><span>                    key <span style=color:#f92672>=</span> args[i][<span style=color:#ae81ff>2</span>:]<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                    env_vars[key] <span style=color:#f92672>=</span> args[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> env_vars
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Settings</span>(BaseSettings):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>settings_customise_sources</span>(
</span></span><span style=display:flex><span>        cls,
</span></span><span style=display:flex><span>        settings_cls: Type[BaseSettings],
</span></span><span style=display:flex><span>        init_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        env_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        dotenv_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        file_secret_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> Tuple[PydanticBaseSettingsSource, <span style=color:#f92672>...</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            env_settings,
</span></span><span style=display:flex><span>            YamlConfigSettingsSource(settings_cls, <span style=color:#e6db74>&#34;config.yaml&#34;</span>),
</span></span><span style=display:flex><span>            CliArgsSource(settings_cls, <span style=color:#e6db74>&#34;app_&#34;</span>),
</span></span><span style=display:flex><span>            init_settings,
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>Now you can pass command-line arguments like <code>--app_host=example.com</code> to override the configurations from the YAML file and environment variables. This way, you can have a single source of truth for all your configurations.</p><h3 id=nested-configurations>Nested Configurations<a hidden class=anchor aria-hidden=true href=#nested-configurations>#</a></h3><p>Pydantic also supports nested models, which can be useful for complex configurations. Let&rsquo;s say you have a nested configuration like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># config.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>database</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>host</span>: <span style=color:#ae81ff>localhost</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>username</span>: <span style=color:#ae81ff>user</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>password</span>: <span style=color:#ae81ff>password</span>
</span></span><span style=display:flex><span><span style=color:#f92672>app</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>version</span>: <span style=color:#ae81ff>1.0</span>
</span></span></code></pre></div><p>You can define nested models like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pydantic <span style=color:#f92672>import</span> BaseModel
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pydantic_settings <span style=color:#f92672>import</span> BaseSettings, SettingsConfigDict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseConfig</span>(BaseModel):
</span></span><span style=display:flex><span>    host: str
</span></span><span style=display:flex><span>    port: int
</span></span><span style=display:flex><span>    username: str
</span></span><span style=display:flex><span>    password: str
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppConfig</span>(BaseModel):
</span></span><span style=display:flex><span>    name: str
</span></span><span style=display:flex><span>    version: str
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Settings</span>(BaseSettings):
</span></span><span style=display:flex><span>    database: DatabaseConfig
</span></span><span style=display:flex><span>    app: AppConfig
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    model_config <span style=color:#f92672>=</span> SettingsConfigDict(env_prefix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;APP_&#34;</span>, env_nested_delimiter<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;__&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>settings_customise_sources</span>(
</span></span><span style=display:flex><span>        cls,
</span></span><span style=display:flex><span>        settings_cls: Type[BaseSettings],
</span></span><span style=display:flex><span>        init_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        env_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        dotenv_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>        file_secret_settings: PydanticBaseSettingsSource,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> Tuple[PydanticBaseSettingsSource, <span style=color:#f92672>...</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            env_settings,
</span></span><span style=display:flex><span>            CliArgsSource(settings_cls, <span style=color:#e6db74>&#34;app_&#34;</span>),
</span></span><span style=display:flex><span>            YamlConfigSettingsSource(settings_cls, <span style=color:#e6db74>&#34;config.yaml&#34;</span>),
</span></span><span style=display:flex><span>            init_settings,
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>You can pass the nested configurations as environment variables with the separator <code>__</code>.</p><p>For example,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export APP_DATABASE__HOST<span style=color:#f92672>=</span>example.com
</span></span><span style=display:flex><span>export APP_DATABASE__PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>export APP_DATABASE__USERNAME<span style=color:#f92672>=</span>admin
</span></span><span style=display:flex><span>export APP_DATABASE__PASSWORD<span style=color:#f92672>=</span>secret
</span></span><span style=display:flex><span>export APP_APP__NAME<span style=color:#f92672>=</span>myapp
</span></span><span style=display:flex><span>export APP_APP__VERSION<span style=color:#f92672>=</span>1.0
</span></span></code></pre></div><p>And since we are using <code>EnvSettingsSource</code> as base class for <code>CliArgsSource</code>, you can pass nested configurations as command-line arguments like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python app.py --app_database__host<span style=color:#f92672>=</span>example.com --app_database__port<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span> --app_database__username<span style=color:#f92672>=</span>admin --app_database__password<span style=color:#f92672>=</span>secret --app_app__name<span style=color:#f92672>=</span>myapp --app_app__version<span style=color:#f92672>=</span>1.0
</span></span></code></pre></div><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>Pydantic and <code>pydantic-settings</code> provide a powerful way to manage configurations in Python. You can load configurations from multiple sources like environment variables, YAML files, and command-line arguments. You can also define nested configurations and customize the sources to suit your needs. This makes it easy to manage configurations in a consistent and type-safe way. I hope this post helps you keep your configurations sane in your Python projects.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ai.ragv.in/tags/yaml/>Yaml</a></li><li><a href=https://ai.ragv.in/tags/configurations/>Configurations</a></li><li><a href=https://ai.ragv.in/tags/python/>Python</a></li><li><a href=https://ai.ragv.in/tags/pydantic/>Pydantic</a></li></ul></footer></article></main><footer class=footer><span>© 2025 <a href=https://ragv.in>Raghava Dhanya</a> · <a href=/license>License</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>