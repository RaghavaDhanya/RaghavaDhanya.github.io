<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Designing Machine Learning Systems for High Velocity Trading | AI Logs</title>
<meta name=keywords content="mlops,python,r,java,ml,ai,time-series"><meta name=description content="As one of my works at Mu Sigma Labs, I was part of a research project on the High Velocity Time Series on early 2019. One of the goals was to create a high velocity trading app using Pair Trading.
The Requisite terms
Long and Short trades
Long trades are buying a security. Short is selling a security even when you don&rsquo;t own it. It generally means that you are borrowing someone&rsquo;s securities and selling them in the hopes of buying it back for lower cost later and returning it and hence, making a profit. You don&rsquo;t really have to do it though; exchanges take care of it and let you sell when you don&rsquo;t own a security."><meta name=author content="Raghava Dhanya"><link rel=canonical href=https://ai.ragv.in/posts/high-velocity-trading-ml-systems/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://ai.ragv.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ai.ragv.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ai.ragv.in/favicon-32x32.png><link rel=apple-touch-icon href=https://ai.ragv.in/apple-touch-icon.png><link rel=mask-icon href=https://ai.ragv.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ai.ragv.in/posts/high-velocity-trading-ml-systems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-RGHWYFE1WN"></script><script>var dnt,doNotTrack=!1;if(!0&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RGHWYFE1WN")}</script><meta property="og:url" content="https://ai.ragv.in/posts/high-velocity-trading-ml-systems/"><meta property="og:site_name" content="AI Logs"><meta property="og:title" content="Designing Machine Learning Systems for High Velocity Trading"><meta property="og:description" content="As one of my works at Mu Sigma Labs, I was part of a research project on the High Velocity Time Series on early 2019. One of the goals was to create a high velocity trading app using Pair Trading.
The Requisite terms Long and Short trades Long trades are buying a security. Short is selling a security even when you don’t own it. It generally means that you are borrowing someone’s securities and selling them in the hopes of buying it back for lower cost later and returning it and hence, making a profit. You don’t really have to do it though; exchanges take care of it and let you sell when you don’t own a security."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-20T21:31:48+05:30"><meta property="article:modified_time" content="2023-06-20T21:31:48+05:30"><meta property="article:tag" content="Mlops"><meta property="article:tag" content="Python"><meta property="article:tag" content="R"><meta property="article:tag" content="Java"><meta property="article:tag" content="Ml"><meta property="article:tag" content="Ai"><meta name=twitter:card content="summary"><meta name=twitter:title content="Designing Machine Learning Systems for High Velocity Trading"><meta name=twitter:description content="As one of my works at Mu Sigma Labs, I was part of a research project on the High Velocity Time Series on early 2019. One of the goals was to create a high velocity trading app using Pair Trading.
The Requisite terms
Long and Short trades
Long trades are buying a security. Short is selling a security even when you don&rsquo;t own it. It generally means that you are borrowing someone&rsquo;s securities and selling them in the hopes of buying it back for lower cost later and returning it and hence, making a profit. You don&rsquo;t really have to do it though; exchanges take care of it and let you sell when you don&rsquo;t own a security."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ai.ragv.in/posts/"},{"@type":"ListItem","position":2,"name":"Designing Machine Learning Systems for High Velocity Trading","item":"https://ai.ragv.in/posts/high-velocity-trading-ml-systems/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Designing Machine Learning Systems for High Velocity Trading","name":"Designing Machine Learning Systems for High Velocity Trading","description":"As one of my works at Mu Sigma Labs, I was part of a research project on the High Velocity Time Series on early 2019. One of the goals was to create a high velocity trading app using Pair Trading.\nThe Requisite terms Long and Short trades Long trades are buying a security. Short is selling a security even when you don\u0026rsquo;t own it. It generally means that you are borrowing someone\u0026rsquo;s securities and selling them in the hopes of buying it back for lower cost later and returning it and hence, making a profit. You don\u0026rsquo;t really have to do it though; exchanges take care of it and let you sell when you don\u0026rsquo;t own a security.\n","keywords":["mlops","python","r","java","ml","ai","time-series"],"articleBody":"As one of my works at Mu Sigma Labs, I was part of a research project on the High Velocity Time Series on early 2019. One of the goals was to create a high velocity trading app using Pair Trading.\nThe Requisite terms Long and Short trades Long trades are buying a security. Short is selling a security even when you don’t own it. It generally means that you are borrowing someone’s securities and selling them in the hopes of buying it back for lower cost later and returning it and hence, making a profit. You don’t really have to do it though; exchanges take care of it and let you sell when you don’t own a security.\nPair Trading The idea of pair trading is to find matching securities that behave similarly and trade when they diverge on the basis that they’ll eventually revert and come back together.\nLet’s take a toy example of two stocks A and B Once you have a good pair security and detect a divergence then the simple strategy is to short the security that is up, long the one that is down.\nHow does it work? Let’s say securities A and B diverge like this So you short A and long B.\nLet’s see how revert can happen after a pair diverges.\nA might be misbehaving, and A comes back down. In this case, since you shorted A, you end up making profit when it goes down and there is little change in B so no loss there. So, in total you are in profit. B might be misbehaving, and B comes back up In this case, since you longed B, you end up making profit when B goes up. And there is little change in A so no loss there. So, in total you are in profit. Both might be misbehaving, and they meet in the middle In this case, you make some profit on A when it goes down due to short and make profit again on B when it goes up. Again, in total you are in profit. These are ideal cases. Most of the time you get a mixture of these, but if the securities are indeed a pair and you detected divergence correctly and within time, you’ll always make profit in an ideal world.\nA pair Let’s define what it is to be a pair a bit more. A straightforward way to think about a pair would be correlated series. The examples above showed positively correlated securities, though that is not necessary. A negatively correlated series would work just as well. You’ll just change the long, short choices. And the pair need not have similar values. You can just buy or sell weighted amounts based on their value. For example, if security A is 5X the value of B historically you can buy/sell 5X the amount of B for every 1X of A.\nCo-Integration Correlation is just one of the ways to define a pair. Another way is to use Co-Integration. Co-Integration is a statistical measure of distance between the two series is stable over time. If the distance is stable over time, then the series’ are said to be co-integrated. So, if they move apart, they’ll eventually come back together.\nYou can think of co-integration as a more general form of correlation. For example, let’s say you are tracking two objects moving, the location and velocity might seem uncorrelated, but the acceleration might be related. So, co-integration can detect these kinds of relationships.\nThe System We wanted to build a system that would automate the process of finding pairs, detecting divergence, figuring out the amount and executing trades. The system would have to do all that in realtime.\nBasic Architecture of the system is as follows: Raw ticker is not enough to make these decisions, so there’ll be some real time feature engineering required. The features/indicators could be anything like OHLC values over a period, Hurst exponent, even social media indicators, etc. The model finally will be consuming the features and outputting the trades. All these are streaming components. We chose Kafka as the backbone of the system since most of our infra was self-hosted. The Kafka was also sink-ed into a InfluxDB to be able reference any historical values. The execution of trades was done by a separate service that would connect to a broker gateway and execute them.\nSystems like this require a lot of experimentation. Features and models will be experimented on. Our focus was to make fast iterations on these. So, we built abstractions/libraries for building these realtime jobs. Data Scientists can write the job in a single file of R/Python, the job abstraction takes care of listening, writing to Kafka, writing to DBs, etc. Abstractions are essential for fast experimentation in data science because they allow data scientists to quickly create prototypes and test new ideas without having to rewrite existing code. They also allow developers to quickly make changes to existing code without having to understand the underlying complexity of the system.\nA general structure of the ML (Machine Learning) job would be as follows:\ndef setup(): # setup code # this is run once when the job starts # this is where you can setup DB connections etc def process(data: dict) -\u003e dict: # process code # this is run for every message on kafka # data is the message # this is where you can do your processing def recover(): # recover code # this is run when the job is recovering from a restart Similarly in R\nsetup \u003c- function() { # setup code # this is run once when the job starts # this is where you can setup DB connections etc } process \u003c- function(data) { # process code # this is run for every message on kafka # data is the message # this is where you can do your processing } recover \u003c- function() { # recover code # this is run when the job is recovering from a restart } This combined with a bunch of helper functions to read/write DBs etc. made it easy to write ML jobs. These jobs would then be wrapped in Java (which was doing things like listening to Kafka etc.) and built into a docker image by our CI system that were deployed on Kubernetes. All these jobs would be horizontally scalable based on how many tickers we wanted to process.\nTo combine all the features into a single topic for consumption by downstream model or in some cases a second order feature engineering we used Apache Spark Structured Streaming. The spark job would read from multiple topics specified in a config and basis the timestamps would perform a streaming join on all the inputs and produce a single output topic.\nThese were all hooked up to a nice little web app built with NodeJS, Angular, WebSockets for monitoring and controlling the system. We showed the system could be run profitably (modestly) on a small set of tickers (100) in paper trading.\nFurther Improvements This system works well when you have one or few models predicting for all pairs of tickers but if we split the models for each pair then the number of deployments would quickly explode (for example, if we have 1000 tickers then we would have 1000*1000 models (= number of possible pairs)). We partially supported this by running the pair level models only if there’s some evidence from the indicators that two tickers could be pairs. This was done by a separate orchestrator service that would listen to the indicators and trigger the pair level models. But it’s still not scalable enough for if we wanted to support all tickers. One of the alternative architectures we explored was to use Akka to build each pair model as an actor and have a separate actor that would listen to the indicators and trigger the pair level actors. This would allow us to scale to any number of tickers.\n","wordCount":"1334","inLanguage":"en","datePublished":"2023-06-20T21:31:48+05:30","dateModified":"2023-06-20T21:31:48+05:30","author":{"@type":"Person","name":"[Raghava Dhanya](https://ragv.in)"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ai.ragv.in/posts/high-velocity-trading-ml-systems/"},"publisher":{"@type":"Person","name":"AI Logs","logo":{"@type":"ImageObject","url":"https://ai.ragv.in/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ai.ragv.in/ accesskey=h title="AI Logs (Alt + H)"><img src=https://ai.ragv.in/Logo_2_0.svg alt aria-label=logo height=30>AI Logs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ai.ragv.in/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://ai.ragv.in/categories/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://ai.ragv.in/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ragv.in title=ragv.in><span>ragv.in</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://ai.ragv.in/archives title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ai.ragv.in/>Home</a>&nbsp;»&nbsp;<a href=https://ai.ragv.in/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Designing Machine Learning Systems for High Velocity Trading</h1><div class=post-meta><span title='2023-06-20 21:31:48 +0530 +0530'>June 20, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;<a href=https://ragv.in>Raghava Dhanya</a></div></header><div class=post-content><p>As one of my works at <a href=https://www.mu-sigma.com/labs>Mu Sigma Labs</a>, I was part of a research project on the High Velocity Time Series on early 2019. One of the goals was to create a high velocity trading app using Pair Trading.</p><h2 id=the-requisite-terms>The Requisite terms<a hidden class=anchor aria-hidden=true href=#the-requisite-terms>#</a></h2><h3 id=long-and-short-trades>Long and Short trades<a hidden class=anchor aria-hidden=true href=#long-and-short-trades>#</a></h3><p>Long trades are buying a <a href=https://en.wikipedia.org/wiki/Security_(finance)>security</a>. Short is selling a security even when you don&rsquo;t own it. It generally means that you are borrowing someone&rsquo;s securities and selling them in the hopes of buying it back for lower cost later and returning it and hence, making a profit. You don&rsquo;t really have to do it though; exchanges take care of it and let you sell when you don&rsquo;t own a security.</p><h3 id=pair-trading>Pair Trading<a hidden class=anchor aria-hidden=true href=#pair-trading>#</a></h3><p>The idea of <a href=https://en.wikipedia.org/wiki/Pairs_trade>pair trading</a> is to find matching securities that behave similarly and trade when they diverge on the basis that they&rsquo;ll eventually revert and come back together.</p><p>Let&rsquo;s take a toy example of two stocks <code>A</code> and <code>B</code>
<img alt="Example of two stocks which are mostly same but for small amount of time they diverge" loading=lazy src=/images/high-velocity-trading-ml-systems/pair-example.png></p><p>Once you have a good pair security and detect a divergence then the simple strategy is to short the security that is up, long the one that is down.</p><h4 id=how-does-it-work>How does it work?<a hidden class=anchor aria-hidden=true href=#how-does-it-work>#</a></h4><p>Let&rsquo;s say securities <code>A</code> and <code>B</code> diverge like this
<img alt="A graph of showing A going up and B going down" loading=lazy src=/images/high-velocity-trading-ml-systems/pair-diverge.png>
So you short <code>A</code> and long <code>B</code>.</p><p>Let&rsquo;s see how revert can happen after a pair diverges.</p><ol><li><code>A</code> might be misbehaving, and <code>A</code> comes back down. <img alt="Same graph as before with A coming down to meet B" loading=lazy src=/images/high-velocity-trading-ml-systems/pair-revert-1.png> In this case, since you shorted <code>A</code>, you end up making profit when it goes down and there is little change in <code>B</code> so no loss there. So, in total you are in profit.</li><li><code>B</code> might be misbehaving, and <code>B</code> comes back up <img alt="Same graph as before with B coming up to meet A" loading=lazy src=/images/high-velocity-trading-ml-systems/pair-revert-2.png> In this case, since you longed <code>B</code>, you end up making profit when <code>B</code> goes up. And there is little change in <code>A</code> so no loss there. So, in total you are in profit.</li><li>Both might be misbehaving, and they meet in the middle <img alt="Same graph as before with B coming up to meet A" loading=lazy src=/images/high-velocity-trading-ml-systems/pair-revert-3.png> In this case, you make some profit on <code>A</code> when it goes down due to short and make profit again on <code>B</code> when it goes up. Again, in total you are in profit.</li></ol><p>These are ideal cases. Most of the time you get a mixture of these, but if the securities are indeed a pair and you detected divergence correctly and within time, you&rsquo;ll always make profit in an ideal world.</p><h3 id=a-pair>A pair<a hidden class=anchor aria-hidden=true href=#a-pair>#</a></h3><p>Let&rsquo;s define what it is to be a pair a bit more. A straightforward way to think about a pair would be correlated series. The examples above showed positively correlated securities, though that is not necessary. A negatively correlated series would work just as well. You&rsquo;ll just change the long, short choices. And the pair need not have similar values. You can just buy or sell weighted amounts based on their value. For example, if security A is 5X the value of B historically you can buy/sell 5X the amount of B for every 1X of A.</p><h4 id=co-integration>Co-Integration<a hidden class=anchor aria-hidden=true href=#co-integration>#</a></h4><p>Correlation is just one of the ways to define a pair. Another way is to use <a href=https://en.wikipedia.org/wiki/Co-integration>Co-Integration</a>. Co-Integration is a statistical measure of distance between the two series is stable over time. If the distance is stable over time, then the series&rsquo; are said to be co-integrated. So, if they move apart, they&rsquo;ll eventually come back together.</p><p>You can think of co-integration as a more general form of correlation. For example, let&rsquo;s say you are tracking two objects moving, the location and velocity might seem uncorrelated, but the acceleration might be related. So, co-integration can detect these kinds of relationships.</p><h2 id=the-system>The System<a hidden class=anchor aria-hidden=true href=#the-system>#</a></h2><p>We wanted to build a system that would automate the process of finding pairs, detecting divergence, figuring out the amount and executing trades. The system would have to do all that in realtime.</p><p>Basic Architecture of the system is as follows:
<img alt="basic architecture of the system" loading=lazy src=/images/high-velocity-trading-ml-systems/basic-architecture.png>
Raw ticker is not enough to make these decisions, so there&rsquo;ll be some real time feature engineering required. The features/indicators could be anything like <a href=https://en.wikipedia.org/wiki/Open-high-low-close_chart>OHLC</a> values over a period, <a href=https://en.wikipedia.org/wiki/Hurst_exponent>Hurst exponent</a>, even social media indicators, etc. The model finally will be consuming the features and outputting the trades. All these are streaming components. We chose Kafka as the backbone of the system since most of our infra was self-hosted. The Kafka was also sink-ed into a InfluxDB to be able reference any historical values. The execution of trades was done by a separate service that would connect to a broker gateway and execute them.</p><p>Systems like this require a lot of experimentation. Features and models will be experimented on. Our focus was to make fast iterations on these. So, we built abstractions/libraries for building these realtime jobs. Data Scientists can write the job in a single file of <code>R</code>/<code>Python</code>, the job abstraction takes care of listening, writing to Kafka, writing to DBs, etc. Abstractions are essential for fast experimentation in data science because they allow data scientists to quickly create prototypes and test new ideas without having to rewrite existing code. They also allow developers to quickly make changes to existing code without having to understand the underlying complexity of the system.</p><p>A general structure of the ML (Machine Learning) job would be as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># setup code</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is run once when the job starts</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is where you can setup DB connections etc</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process</span>(data: dict) <span style=color:#f92672>-&gt;</span> dict:
</span></span><span style=display:flex><span>    <span style=color:#75715e># process code</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is run for every message on kafka</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># data is the message</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is where you can do your processing</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>recover</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># recover code</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is run when the job is recovering from a restart</span>
</span></span></code></pre></div><p>Similarly in R</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>setup <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e># setup code</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is run once when the job starts</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is where you can setup DB connections etc</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>process <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>function</span>(data) {
</span></span><span style=display:flex><span>    <span style=color:#75715e># process code</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is run for every message on kafka</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># data is the message</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is where you can do your processing</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>recover <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e># recover code</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this is run when the job is recovering from a restart</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This combined with a bunch of helper functions to read/write DBs etc. made it easy to write ML jobs. These jobs would then be wrapped in <code>Java</code> (which was doing things like listening to Kafka etc.) and built into a docker image by our CI system that were deployed on Kubernetes. All these jobs would be horizontally scalable based on how many tickers we wanted to process.</p><p>To combine all the features into a single topic for consumption by downstream model or in some cases a second order feature engineering we used <a href=https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#overview>Apache Spark Structured Streaming</a>. The spark job would read from multiple topics specified in a config and basis the timestamps would perform a streaming join on all the inputs and produce a single output topic.</p><p>These were all hooked up to a nice little web app built with NodeJS, Angular, WebSockets for monitoring and controlling the system.
<img alt="UI screenshot" loading=lazy src=/images/high-velocity-trading-ml-systems/screenshot.jpg></p><p>We showed the system could be run profitably (modestly) on a small set of tickers (100) in paper trading.</p><h2 id=further-improvements>Further Improvements<a hidden class=anchor aria-hidden=true href=#further-improvements>#</a></h2><p>This system works well when you have one or few models predicting for all pairs of tickers but if we split the models for each pair then the number of deployments would quickly explode (for example, if we have 1000 tickers then we would have 1000*1000 models (= number of possible pairs)). We partially supported this by running the pair level models only if there&rsquo;s some evidence from the indicators that two tickers could be pairs. This was done by a separate orchestrator service that would listen to the indicators and trigger the pair level models. But it&rsquo;s still not scalable enough for if we wanted to support all tickers. One of the alternative architectures we explored was to use <a href=https://akka.io/>Akka</a> to build each pair model as an actor and have a separate actor that would listen to the indicators and trigger the pair level actors. This would allow us to scale to any number of tickers.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ai.ragv.in/tags/mlops/>Mlops</a></li><li><a href=https://ai.ragv.in/tags/python/>Python</a></li><li><a href=https://ai.ragv.in/tags/r/>R</a></li><li><a href=https://ai.ragv.in/tags/java/>Java</a></li><li><a href=https://ai.ragv.in/tags/ml/>Ml</a></li><li><a href=https://ai.ragv.in/tags/ai/>Ai</a></li><li><a href=https://ai.ragv.in/tags/time-series/>Time-Series</a></li></ul></footer></article></main><footer class=footer><span>© 2025 <a href=https://ragv.in>Raghava Dhanya</a> · <a href=/license>License</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>